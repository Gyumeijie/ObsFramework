//
//
// CC_ManoeuvreFactory.h
//
// This file was automatically generated by an XSL program
//


#ifndef CC_MANOEUVREFACTORY_H
#define CC_MANOEUVREFACTORY_H


#include "../GeneralInclude/ForwardDeclarations.h"
#include "../GeneralInclude/BasicTypes.h"
#include "../Base/CC_RootObject.h"   
#include "../Manoeuvre/DC_DummyConfigurableManoeuvre.h"  
#include "../Manoeuvre/DC_DummyManoeuvre.h"  
#include "../Manoeuvre/DC_TestPUSConfigurableManoeuvre.h"  
#include "../Qom/object.h"


/*
 * Dynamic factory for components of type: <code>Manoeuvre</code>.
 * A <i>dynamic factory</i> is a component that manages a pool of instances of
 * components of a certain type. Clients of the factory can require one of these
 * instances at run-time. After the factory hands over a component instance to its
 * client, the instance is marked as "in use" and cannot be given to any other
 * clients. When the requesting client has finished using the instance, it should release
 * it by marking it as "no longer in use". This will allow the factory to make it
 * available to other clients that request it. The "in use" status of the component
 * instances is controlled through method <code>setInUse</code> declared on
 * the component instances.
 * <p>
 * A dynamic factory is configured in two steps. The first step is performed
 * by the factory constructor when the internal data structures to hold the component
 * instances are created. The second step is performed during application initialization
 * when the component instances are loaded in the factory. Reconfiguration at run time
 * during normal application operation is not allowed.
 * <p>
 * Dynamic factories are implemented as singletons. They can exist in one single instance
 * that can be accessed through the <code>getInstance</code> method.
 * The one single instance of the class is created the first time that method
 * getInstance is called. In order to avoid possible disruptions of
 * real-time behaviour, applications should ensure that this method has been called
 * at least once before the application enters its operational phase.
 * <p>
 * This factory manages the following component instances:<ul>  
 * <li>Number of instances of type <code>DC_DummyConfigurableManoeuvre</code>: 1</li>    
 * <li>Number of instances of type <code>DC_DummyManoeuvre</code>: 1</li>    
 * <li>Number of instances of type <code>DC_TestPUSConfigurableManoeuvre</code>: 1</li>    
 * </ul>
 * The code for this class was automatically generated by an XSL program processing
 * the XML-based application model.    
 * @ingroup Manoeuvre
 * @see Manoeuvre
 * @author Automatically Generated Class
 * @version 1.0
 */
#define TYPE_CC_MANOEUVREFACTORY "cc_manoeuvrefactory"

void CC_ManoeuvreFactory_register(void);


///////////////////////////////////////////////////////////////////////////////
//
//                            class and struct
//
///////////////////////////////////////////////////////////////////////////////

struct CC_ManoeuvreFactory {
    CC_RootObject parent;

    unsigned int sizeDummyConfigurableManoeuvre;
    DC_DummyConfigurableManoeuvre **poolDummyConfigurableManoeuvre;

    unsigned int sizeDummyManoeuvre;
    DC_DummyManoeuvre **poolDummyManoeuvre;

    unsigned int sizeTestPUSConfigurableManoeuvre;
    DC_TestPUSConfigurableManoeuvre **poolTestPUSConfigurableManoeuvre;
};


struct CC_ManoeuvreFactoryClass {
    CC_RootObjectClass parent_class;
};


#define CC_MANOEUVREFACTORY_GET_CLASS(obj) \
        OBJECT_GET_CLASS(CC_ManoeuvreFactoryClass, obj, TYPE_CC_MANOEUVREFACTORY)

#define CC_MANOEUVREFACTORY_CLASS(klass) \
        OBJECT_CLASS_CHECK(CC_ManoeuvreFactoryClass, klass, TYPE_CC_MANOEUVREFACTORY)

#define CC_MANOEUVREFACTORY(obj) \
        OBJECT_CHECK(CC_ManoeuvreFactory, obj, TYPE_CC_MANOEUVREFACTORY)


CC_ManoeuvreFactory* CC_ManoeuvreFactory_new(void);


///////////////////////////////////////////////////////////////////////////////
//
//                            class method(s) declaration
//
///////////////////////////////////////////////////////////////////////////////

/**
 * Get the single instance of this singleton class. If the instance does not
 * yet exist, it is created.
 */
CC_ManoeuvreFactory* CC_ManoeuvreFactory_getInstance(void);



///////////////////////////////////////////////////////////////////////////////
//
//                 non-virtual member method(s) declaration
//
///////////////////////////////////////////////////////////////////////////////

/**
 * general interface for all Manoeuver setter methods
 *
 * @param i the index in the internal array
 * @param pItem the component instance
 */

void CC_ManoeuvreFactory_setManoeuvre
(
    CC_ManoeuvreFactory *This, 
    unsigned int i,
    Manoeuvre *pItem
);


/**
 * Load one instance of type <code>DC_DummyConfigurableManoeuvre</code> in the
 * factory. The component instances managed by the factory are internally stored in an
 * array. This method loads the i-th element of the array. The argument i should lie
 * in the interval [0, N-1] where N is the number of component instances of type
 * <code>DC_DummyConfigurableManoeuvre</code>. The value of N is defined by
 * the class constructor.
 * <p>
 * The "in use" status of a newly loaded component is initialized
 * to: "component is not in use".
 * <p>
 * This is an initialization method that should only be called during the application
 * configuration phase.
 * @param i the index in the internal array
 * @param pItem the component instance
 */
static void setDummyConfigurableManoeuvre
(
    CC_ManoeuvreFactory *This, 
    unsigned int i,
    DC_DummyConfigurableManoeuvre *pItem
);

/**
 * Return the number of component instances of type <code>DC_DummyConfigurableManoeuvre</code>
 * that are currently allocated. A component instance is allocated if its "in use" status is
 * equal to: "component is in use".
 * @return the number of allocated component instances
 */
unsigned int CC_ManoeuvreFactory_getNumberDummyConfigurableManoeuvre
(
   CC_ManoeuvreFactory *This
);

/**
 * Return the number of component instances of type <code>DC_DummyConfigurableManoeuvre</code>
 * that are in the factory. The value returned is the maximum number of component instances of
 * type <code>DC_DummyConfigurableManoeuvre</code> that can be allocated.
 * @return the total number of component instances in the factory of
 * type <code>DC_DummyConfigurableManoeuvre</code>
 */
unsigned int CC_ManoeuvreFactory_getCapacityDummyConfigurableManoeuvre
(
    CC_ManoeuvreFactory *This
);

/**
 * Allocate one instance of type <code>DC_DummyConfigurableManoeuvre</code>.
 * This method scans all the entries in the factory of type <code>DC_DummyConfigurableManoeuvre</code>
 * and returns the first one which is not in use. 
 * Before being returned to the caller, 
 * the status of the component instance is changed to: "in use". A client that receives
 * a component instance through a call to this method, should release the instance when it
 * no longer needs it. This can be done by calling
 * method <code>CC_ManoeuvreFactory_setInUse(false)</code> on the component itself.
 * <p>
 * If no free component instances are found, then the method returns null. Note that no
 * event report is generated to record the failure to allocate a component instance. Event
 * reporting is the responsibility of the caller.      
 * @return the allocated component instance or null if no free instances were found
 */
DC_DummyConfigurableManoeuvre* CC_ManoeuvreFactory_allocateDummyConfigurableManoeuvre
(
    CC_ManoeuvreFactory *This
);

/**
 * Check whether a non-allocated component instance of type <code>DC_DummyConfigurableManoeuvre</code>
 * is available within the factory. If this method return true, then the corresponding
 * <code>allocate</code> method is guaranteed to return a non-null value.
 * The method parameters are used as in the corresponding <code>allocate</code> method.
 * @see #allocateDC_DummyConfigurableManoeuvre     
 * @return true if free instances of type DC_DummyConfigurableManoeuvre are available, 
 * false otherwise
 */
bool CC_ManoeuvreFactory_isFreeDummyConfigurableManoeuvre
(
    CC_ManoeuvreFactory *This
);

/**
 * Load one instance of type <code>DC_DummyManoeuvre</code> in the
 * factory. The component instances managed by the factory are internally stored in an
 * array. This method loads the i-th element of the array. The argument i should lie
 * in the interval [0, N-1] where N is the number of component instances of type
 * <code>DC_DummyManoeuvre</code>. The value of N is defined by
 * the class constructor.
 * <p>
 * The "in use" status of a newly loaded component is initialized
 * to: "component is not in use".
 * <p>
 * This is an initialization method that should only be called during the application
 * configuration phase.
 * @param i the index in the internal array
 * @param pItem the component instance
 */
static void setDummyManoeuvre
(
    CC_ManoeuvreFactory *This, 
    unsigned int i, 
    DC_DummyManoeuvre *pItem
);

/**
 * Return the number of component instances of type <code>DC_DummyManoeuvre</code>
 * that are currently allocated. A component instance is allocated if its "in use" status is
 * equal to: "component is in use".
 * @return the number of allocated component instances
 */
unsigned int CC_ManoeuvreFactory_getNumberDummyManoeuvre
(
    CC_ManoeuvreFactory *This
);

/**
 * Return the number of component instances of type <code>DC_DummyManoeuvre</code>
 * that are in the factory. The value returned is the maximum number of component instances of
 * type <code>DC_DummyManoeuvre</code> that can be allocated.
 * @return the total number of component instances in the factory of
 * type <code>DC_DummyManoeuvre</code>
 */
unsigned int CC_ManoeuvreFactory_getCapacityDummyManoeuvre
(
    CC_ManoeuvreFactory *This
);

/**
 * Allocate one instance of type <code>DC_DummyManoeuvre</code>.
 * This method scans all the entries in the factory of type <code>DC_DummyManoeuvre</code>
 * and returns the first one which is not in use. 
 * Before being returned to the caller, 
 * the status of the component instance is changed to: "in use". A client that receives
 * a component instance through a call to this method, should release the instance when it
 * no longer needs it. This can be done by calling
 * method <code>CC_ManoeuvreFactory_setInUse(false)</code> on the component itself.
 * <p>
 * If no free component instances are found, then the method returns null. Note that no
 * event report is generated to record the failure to allocate a component instance. Event
 * reporting is the responsibility of the caller.      
 * @return the allocated component instance or null if no free instances were found
 */
DC_DummyManoeuvre* CC_ManoeuvreFactory_allocateDummyManoeuvre
(
    CC_ManoeuvreFactory *This
);

/**
 * Check whether a non-allocated component instance of type <code>DC_DummyManoeuvre</code>
 * is available within the factory. If this method return true, then the corresponding
 * <code>allocate</code> method is guaranteed to return a non-null value.
 * The method parameters are used as in the corresponding <code>allocate</code> method.
 * @see #allocateDC_DummyManoeuvre     
 * @return true if free instances of type DC_DummyManoeuvre are available, 
 * false otherwise
 */
bool CC_ManoeuvreFactory_isFreeDummyManoeuvre
(
    CC_ManoeuvreFactory *This
);

/**
 * Load one instance of type <code>DC_TestPUSConfigurableManoeuvre</code> in the
 * factory. The component instances managed by the factory are internally stored in an
 * array. This method loads the i-th element of the array. The argument i should lie
 * in the interval [0, N-1] where N is the number of component instances of type
 * <code>DC_TestPUSConfigurableManoeuvre</code>. The value of N is defined by
 * the class constructor.
 * <p>
 * The "in use" status of a newly loaded component is initialized
 * to: "component is not in use".
 * <p>
 * This is an initialization method that should only be called during the application
 * configuration phase.
 * @param i the index in the internal array
 * @param pItem the component instance
 */
static void setTestPUSConfigurableManoeuvre
(
    CC_ManoeuvreFactory *This, 
    unsigned int i, 
    DC_TestPUSConfigurableManoeuvre *pItem
);

/**
 * Return the number of component instances of type <code>DC_TestPUSConfigurableManoeuvre</code>
 * that are currently allocated. A component instance is allocated if its "in use" status is
 * equal to: "component is in use".
 * @return the number of allocated component instances
 */
unsigned int CC_ManoeuvreFactory_getNumberTestPUSConfigurableManoeuvre
(
    CC_ManoeuvreFactory *This
);

/**
 * Return the number of component instances of type <code>DC_TestPUSConfigurableManoeuvre</code>
 * that are in the factory. The value returned is the maximum number of component instances of
 * type <code>DC_TestPUSConfigurableManoeuvre</code> that can be allocated.
 * @return the total number of component instances in the factory of
 * type <code>DC_TestPUSConfigurableManoeuvre</code>
 */
unsigned int CC_ManoeuvreFactory_getCapacityTestPUSConfigurableManoeuvre
(
    CC_ManoeuvreFactory *This
);

/**
 * Allocate one instance of type <code>DC_TestPUSConfigurableManoeuvre</code>.
 * This method scans all the entries in the factory of type <code>DC_TestPUSConfigurableManoeuvre</code>
 * and returns the first one which is not in use. 
 * Before being returned to the caller, 
 * the status of the component instance is changed to: "in use". A client that receives
 * a component instance through a call to this method, should release the instance when it
 * no longer needs it. This can be done by calling
 * method <code>CC_ManoeuvreFactory_setInUse(false)</code> on the component itself.
 * <p>
 * If no free component instances are found, then the method returns null. Note that no
 * event report is generated to record the failure to allocate a component instance. Event
 * reporting is the responsibility of the caller.      
 * @return the allocated component instance or null if no free instances were found
 */
DC_TestPUSConfigurableManoeuvre* CC_ManoeuvreFactory_allocateTestPUSConfigurableManoeuvre
(
    CC_ManoeuvreFactory *This
);

/**
 * Check whether a non-allocated component instance of type <code>DC_TestPUSConfigurableManoeuvre</code>
 * is available within the factory. If this method return true, then the corresponding
 * <code>allocate</code> method is guaranteed to return a non-null value.
 * The method parameters are used as in the corresponding <code>allocate</code> method.
 * @see #allocateDC_TestPUSConfigurableManoeuvre     
 * @return true if free instances of type DC_TestPUSConfigurableManoeuvre are available, 
 * false otherwise
 */
bool CC_ManoeuvreFactory_isFreeTestPUSConfigurableManoeuvre
(
    CC_ManoeuvreFactory *This
);


#endif
