//
//
// CC_IntStack.h
//
//


#ifndef CC_INTSTACK_H
#define CC_INTSTACK_H


#include "../GeneralInclude/ForwardDeclarations.h"
#include "../GeneralInclude/BasicTypes.h"
#include "../Base/CC_RootObject.h"
#include "../Qom/object.h"


/*
 * Stack-like container class for items of type: <code>int</code>. 
 * This class was automatically generated by an XSLT program.
 * It models a FIFO container with a fixed size. The items in the container are
 * handled as variables of type: <code>int</code>. This is 
 * a type-safe class that does not perform any type casting.
 * The size of the stack must be set by the user during the initialization phase
 * and cannot be changed afterwards. This class offers the two traditional <i>push</i>
 * and <i>pop</i> operations and a <i>reset</i> operation that empties the stack.
 * Attempts to push a full stack or to pop an empty stack result in no action other
 * than the generation of an event report.
 * @author Alessandro Pasetti(P&P Software)
 * @version 1.0
 */
#define TYPE_CC_INTSTACK "cc_intstack"

void CC_IntStack_register(void);


///////////////////////////////////////////////////////////////////////////////
//
//                            class and struct
//
///////////////////////////////////////////////////////////////////////////////

struct CC_IntStack {
    CC_RootObject parent;

    unsigned int size;		
    unsigned int stackPointer;	// index of next free location on stack		
    int *pStack;     // Array of pointers to the items in the stack.
};


struct CC_IntStackClass {
    CC_RootObjectClass parent_class;
};


#define CC_INTSTACK_GET_CLASS(obj) \
        OBJECT_GET_CLASS(CC_IntStackClass, obj, TYPE_CC_INTSTACK)

#define CC_INTSTACK_CLASS(klass) \
        OBJECT_CLASS_CHECK(CC_IntStackClass, klass, TYPE_CC_INTSTACK)

#define CC_INTSTACK(obj) \
        OBJECT_CHECK(CC_IntStack, obj, TYPE_CC_INTSTACK)


CC_IntStack* CC_IntStack_new(void);


///////////////////////////////////////////////////////////////////////////////
//
//                 non-virtual member method(s) declaration
//
///////////////////////////////////////////////////////////////////////////////

/**
 * Push an item onto the stack.
 * If the stack is already full, no action is taken but event report
 * EVT_STACK_FULL is generated to report the fact. Users should always check that the
 * stack is not CC_IntStack_full(using operation <code>isFull</code>) before performing
 * a push operation. 
 * @see TD_EventType
 * @param newItem the new item to be added to the stack
 */
void CC_IntStack_push(CC_IntStack *This, int newItem);

/**
 * Pop an item from the stack.
 * If the stack is empty, the value of NULL is returned and event report
 * EVT_STACK_FULL is generated to report the fact. Users should always check that the
 * stack is not CC_IntStack_empty(using operation <code>isEmpty</code>) before performing
 * a pop operation. 
 * @see TD_EventType
 * @return the most recently item pushed onto the stack or NULL if the stack is 
 * empty
 */
int CC_IntStack_pop(CC_IntStack *This);

/**
 * Set the size of the stack. The size of the stack is the maximum number of
 * items that can be held by the stack. A call to this method causes the internal 
 * FIFO data structure where the stack items are stored to be created and initialized.
 * <p>
 * This is an initialization method. It should be called before the
 * stack is used for the first time and it should not be called more
 * than once. Attempts to call it more than once will result in memory leaks.
 * It is not legal to set the repository size to 0.     
 * @param size the desired size of the stack
 */
void CC_IntStack_setStackSize(CC_IntStack *This, unsigned int size);

/**
 * Return the size of the stack.      
 * @see #setStackSize
 * @return the desired size of the stack
 */
unsigned int CC_IntStack_getStackSize(const CC_IntStack *This);

/**
 * Return the number of items currently on the stack.      
 * @return the number of items currently on the stack
 */
unsigned int CC_IntStack_getNumberOfItems(const CC_IntStack *This);

/**
 * Check whether the stack is emtpy
 * @return true if the stack is emtpy, false otherwise
 */
bool CC_IntStack_isEmpty(const CC_IntStack *This);

/**
 * Check whether the stack is full
 * @return true if the stack is full, false otherwise
 */
bool CC_IntStack_isFull(const CC_IntStack *This);

/**
 * Reset the stack.
 * The stack is brought back to the status it had after it was
 * configured but before it was ever used.
 */
void CC_IntStack_reset(CC_IntStack *This);


#endif
